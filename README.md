# dongbinna_CodingTest_Python
이것이 코딩테스트다 with 파이썬 책 문제 정리  
# PART 01 코테 준비하기
## ch1. 코딩테스트 개요  
### 코딩테스트 준비
* 코드업 - https://codeup.kr  
-파이썬 기초 100제 풀이 완료  
* 백준 온라인 저지 - https://www.acmicpc.net/
* 프로그래머스 - https://school.programmers.co.kr/learn/challenges
* SW Expert Academy - https://swexpertacademy.com  
-22년 하계 대학생 S/W 알고리즘 역량강화 과정 수료     
### 복잡도  
* 시간복잡도  
  * N < 500 인경우 : O(N^3) 인 알고리즘을 설계하면 풀 수 있다
  * N < 2000 인경우 : O(N^2) 인 알고리즘을 설계하면 풀 수 있다  
  * N < 100,000 인 경우 : O(NlogN) 인 알고리즘을 설계하면 풀 수 있다  
  * N < 10,000,000 인 경우 : O(N) 인 알고리즘을 설계하면 풀 수 있다  
* 공간복잡도  
  * int a[1000] : 4KB
  * int a[1000000] : 4MB  
  * int a[2000][2000] : 16MB  
  
일반적인 경우 데이터 개수가 1000만 단위를 넘어가지 않도록 설계를 해야한다  
## ch2. 기출문제 유형 분석  
* 기본적인 알고리즘에 대한 이해와 문제 해결 능력을 기르자  

---
# PART 02 주요 알고리즘 이론과 실전문제  
## ch3. 그리디  
* 현재 상황에서 지금 당장 좋은 것만 고르는 방법
* 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토가 가능해야 한다  
<br>  

> example3-2. [큰 수의 법칙](https://github.com/hoho0161/dongbinna_CodingTest_Python/blob/master/ch3.greedy/example3-2.py)  
> 그리디 방법으로 선택했을 때 반복되는 구조가 있는지 확인하기  

> example3-4. [1이 될 때까지](https://github.com/hoho0161/dongbinna_CodingTest_Python/blob/master/ch3.greedy/example3-4.py)  
> 반복되는 일을 한번에 처리할 수 있는지 확인하기  

## ch4. 구현  
* 구현은 '머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정'  
* 완전탐색 - 모든 경우의 수를 주저 없이 다 계산하는 해결방법
* 시뮬레이션 - 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행  
* 파이썬은 직접 자료형을 지정할 필요가 없으며 매우 큰 수의 연산 또한 기본으로 지원한다  
## ch5. DFS/BFS  
* 스택은 별도의 라이브러리 필요x  
기본 리스트에서 append(), pop() 메서드를 사용하면 된다  
* 큐는 collections 모듈의 deque를 사용한다  

<br>

### DFS - Depth-First Search, 깊이 우선 탐색  
* 스택을 이용하는 알고리즘이기 때문에 실제 구현은 재귀 함수를 이용했을 때 매우 간결하다  
### BFS - Breadth-First Search, 너비 우선 탐색  
* 큐 자료구조를 이용하여 구현한다  

## ch6. 정렬  
* 데이터를 특정한 기준에 따라 순서대로 나열  
데이터가 정렬되어있으면 이진 탐색이 가능해진다  
  
### 선택 정렬 (Selection Sort)  
* 매번 가장 작은 것을 선택하여 앞(정렬된 데이터 뒤)으로 옮긴다  
O(N^2)의 복잡도를 가지며 10,000개 이상의 경우 속도가 급격히 느려진다  
### 삽입 정렬 (Insertion Sort)  
* 하나씩 확인해 적절한 위치에 삽입하는 방법  
직관적이며 데이터가 거의 정렬되어 있으면 훨씬 효율적이다  
O(N^2)의 복잡도를 가지며 최선의 경우 O(N)의 복잡도를 가진다  
### 퀵 정렬 (Quick Sort)  
* 기준 데이터를 설정하고 그 기준보다 큰,작은 데이터 위치를 바꿔 정렬  
기준 데이터인 피벗(Pivot)을 사용한다
평균 시간 복잡도는 O(NlogN)이며 앞의 선택, 삽입 정렬보다 매우 빠른편이다  
이미 데이터가 정렬되어 있는 경우 피벗을 왼쪽 데이터로 삼으면 매우 느리게 작동 - 피벗 선정에도 방법이 많다  
### 계수 정렬 (Count Sort)  
* 특정 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘  
데이터가 N개 최대값이 K일 때, 최악의 경우에도 O(N+K)를 보장  
  * 조건 - 데이터의 크기 범위가 제한되어 정수 형태로 표현할수 있을 때 사용  
일반적으로 가장 큰 데이터와 가장 작은 데이터 차이가 1,000,000을 넘지 않을 때 효과적  

### 파이썬 정렬 라이브러리  
코테에서 나오는 3가지 유형  
* 정렬 라이브러리로 풀 수 있는 문제
* 정렬 알고리즘 원리에 대해 물어보는 문제
* 더 빠른 정렬이 필요한 문제  

## ch7. 이진 탐색  
* 순차 탐색  
  리스트 안에 특정한 데이터를 찾기 위해 앞에서부터 하나씩 차례대로 확인하는 방법  
  시간 복잡도는 O(N)이다  
* 이진 탐색  
  찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교  
  시간 복잡도는 O(logN)이다  

##### 빠르게 입력받기  
```
import sys
input_data = sys.stdin.readline().rstrip()  
```  
> example7-2. [떡볶이 떡 만들기](https://github.com/hoho0161/dongbinna_CodingTest_Python/blob/master/ch7.binarySearch/example7-2.py)  
> 파라메트릭 서치 문제 최적화 문제를 결정 문제로 바꾸어 해결한다  
> 이진 탐색으로 데이터가 조건을 만족하는지 확인

## ch8. 다이나믹 프로그래밍 DP  
* 메모리를 활용해 연산 속도를 비약적으로 증가시키는 방법  
* 조건
  1. 큰 문제를 작은 문제로 나눌 수 있다  
  2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다  
* 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다  
* 결과 저장용 리스트는 'DP 테이블'이라 불린다  

## ch9. 최단경로  
### 다익스트라 알고리즘  
* 특정 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘  
* 음의 간선이 없을 때 정상적으로 작동한다  
* 그리디 알고리즘으로 분류 - 매번 '가장 비용이 적은 노드'를 선택해서 임의의 과정을 반복하기 때문  

#### 순서
1. 출발 노드 설정  
2. 최단 거리 테이블 초기화  
3. 방문하지 않은 노드 중에서 최단 거리가 짧은 노드 선택  
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산해 최단 거리 테이블 갱신  
5. 3번 4번 과정 반복  

[간단한 다익스트라](https://github.com/hoho0161/dongbinna_CodingTest_Python/blob/master/ch9.Shortest_Path/Dijkstra_ver1.py)  
시간 복잡도는 O(V^2)이며 최단 거리가 가장 짧은 노드를 매번 선형탐색해야 하며 현재 노드와 연결된 노드를 일일이 확인하기 때문이다  
  
[개선된 다익스트라](https://github.com/hoho0161/dongbinna_CodingTest_Python/blob/master/ch9.Shortest_Path/Dijkstra_ver2.py)  
최악의 경우 시간 복잡도 O(ElogV)를 보장하여 해결할 수 있다  
힙 자료구조를 사용해 선형탐색을 하여 찾던 부분을 개선  
```
import heapq
q = []
heapq.heappush(q,(0,start))
while q:
    dist, now = heapq.heappop(q)
```
표준 라이브러리로 제공하는 heapq 사용방법  

### [플로이드 워셜 알고리즘](https://github.com/hoho0161/dongbinna_CodingTest_Python/blob/master/ch9.Shortest_Path/Floyd_Warshall.py)  
* 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우 사용하는 알고리즘  
* 시간 복잡도는 O(N^3)이며 점화식에 맞게 갱신하기 때문에 다이나믹 프로그래밍으로 볼 수 있다  

## ch10. 그래프 이론  
### 서로소 집합 (Disjoint Sets)  
* 공통 원소가 없는 두 집합을 의미한다
* 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조 (union-find 자료구조라고 불리기도함)  
* 트리 자료구조를 이용하여 집합을 표현하며 부모테이블을 find함수로 재귀적으로 갱신을 하여 시간복잡도를 개선하는 경로 압축 기법을 사용하는 것이 좋다  
* 서로소 집합을 사용하여 사이클 판별을 할 수 있다  
  
### 신장 트리 (Spanning Tree)  
* 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프
* 가능한 최소한의 비용으로 신장트리를 찾아야 할 때 [크루스칼 알고리즘](https://github.com/hoho0161/dongbinna_CodingTest_Python/blob/master/ch10.Graph/Spanning_Tree.py)(Kruskal Algorithm)을 생각할 수 있다.  

### 위상 정렬 (Topology Sort)  
* 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것  
* 기본적인 예시로는 '선수과목을 고려한 학습순서'등이 있으며 문제에 사이클이 발생하지 않는다고 명시한 경우가 많다  
* 위상 정렬의 시간 복잡도는 O(V+E) 이다
